import com.github.glassmc.kiln.standard.CustomRemapper
import org.objectweb.asm.Type
import org.objectweb.asm.tree.AbstractInsnNode
import org.objectweb.asm.tree.AnnotationNode
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.FieldInsnNode
import org.objectweb.asm.tree.FieldNode
import org.objectweb.asm.tree.MethodInsnNode
import org.objectweb.asm.tree.MethodNode

import static com.github.glassmc.kiln.standard.DependencyHandlerExtension.*

buildscript {
    repositories {
        mavenCentral()
        maven {
            url = 'https://jitpack.io/'
        }
        maven {
            url = 'https://glassmc.ml/repository/'
        }
    }

    dependencies {
        classpath 'com.github.glassmc:kiln:0.6.18'
    }
}

apply plugin: 'kiln-main'

sourceCompatibility = targetCompatibility = 1.8

repositories {
    mavenCentral()

    maven {
        url = 'https://glassmc.ml/repository/'
    }

    maven {
        url = 'https://repo.spongepowered.org/repository/maven-public/'
    }
}

dependencies {
    implementation 'com.github.glassmc:loader:0.8.3'

    implementation minecraft('client', '1.7.10', 'yarn')
    implementation minecraft('client', '1.8.9', 'mcp')
    implementation minecraft('client', '1.17.1', 'yarn')
    implementation minecraft('client', '1.18.1', 'mojang')

    implementation 'org.ow2.asm:asm-tree:9.2'

    implementation 'com.github.glassmc:mixin:1.0:mapped'
}

kiln {
    remappers = [new MixinRemapper()]
}

class MixinRemapper extends CustomRemapper {

    private final Map<String, String> mixinClasses = new HashMap<>()
    private Map<String, ClassNode> classNodes

    @Override
    void map(Map<String, ClassNode> classNodes) {
        this.classNodes = classNodes

        for(String className : classNodes.keySet()) {
            ClassNode classNode = classNodes.get(className)

            for (AnnotationNode annotationNode : classNode.invisibleAnnotations) {
                if (annotationNode.desc = "Lorg/spongepowered/asm/mixin/Mixin;") {
                    if (annotationNode.values != null) {
                        List<Type> values = annotationNode.values.get(annotationNode.values.indexOf("value") + 1) as List<Type>
                        if (values.get(0) instanceof Type) {
                            mixinClasses.put(className, values.get(0).className.replace(".", "/"))

                            List<Type> oldValues = new ArrayList<>(values)
                            values.clear()

                            for (Type type : oldValues) {
                                values.add(Type.getType("L" + this.parent.map(type.getClassName().replace(".", "/")) + ";"))
                            }
                        }
                    }
                }
            }

            for(FieldNode fieldNode : classNode.fields) {
                if(this.getMixinClass(className) != null) {
                    for(AnnotationNode annotationNode : fieldNode.visibleAnnotations) {
                        if(annotationNode.desc == "Lorg/spongepowered/asm/mixin/Shadow;") {
                            fieldNode.name = this.mapFieldName(className, fieldNode.name, fieldNode.desc)
                        }
                    }
                }
            }

            for(MethodNode methodNode : classNode.methods) {

                if(this.getMixinClass(className) != null) {
                    for(AnnotationNode annotationNode : methodNode.visibleAnnotations) {
                        if(annotationNode.desc == "Lorg/spongepowered/asm/mixin/gen/Invoker;" ||
                                annotationNode.desc == "Lorg/spongepowered/asm/mixin/gen/Accessor;" ||
                                annotationNode.desc == "Lorg/spongepowered/asm/mixin/Overwrite;" ||
                                annotationNode.desc == "Lorg/spongepowered/asm/mixin/Shadow;") {
                            methodNode.name = this.mapMethodName(className, methodNode.name, methodNode.desc)
                        }
                    }

                    for(AnnotationNode annotationNode : methodNode.visibleAnnotations) {
                        if(annotationNode.desc == "Lorg/spongepowered/asm/mixin/injection/Inject;" ||
                                annotationNode.desc == "Lorg/spongepowered/asm/mixin/injection/Redirect;") {
                            List<String> targets = annotationNode.values.get(annotationNode.values.indexOf("method") + 1) as List<String>
                            List<String> newTargets = new ArrayList<>()
                            for(String string : targets) {
                                int splitIndex = string.indexOf('(')
                                String name = string.substring(0, splitIndex)
                                String desc = string.substring(splitIndex)
                                newTargets.add(this.getParent().mapMethodName(this.getMixinClass(className), name, desc) + this.getParent().mapMethodDesc(desc))
                            }
                            int index = annotationNode.values.indexOf(targets)
                            annotationNode.values.remove(targets)
                            annotationNode.values.add(index, newTargets)
                        }
                        if(annotationNode.values != null && annotationNode.values.contains("at")) {
                            AnnotationNode atAnnotation = annotationNode.values.get(annotationNode.values.indexOf("at") + 1) as AnnotationNode
                            if(atAnnotation.values.contains("target")) {
                                String target = atAnnotation.values.get(atAnnotation.values.indexOf("target") + 1)

                                String[] classMethodSplit = target.split(";")
                                String className1 = classMethodSplit[0].substring(1)
                                int methodDescIndex = classMethodSplit[1].indexOf('(')
                                String methodName = classMethodSplit[1].substring(0, methodDescIndex)
                                String methodDesc = classMethodSplit[1].substring(methodDescIndex)

                                int targetIndex = atAnnotation.values.indexOf(target)
                                atAnnotation.values.remove(target)
                                atAnnotation.values.add(targetIndex, "L" + this.getParent().map(className1) + ";" + this.getParent().mapMethodName(className1, methodName, methodDesc) + this.getParent().mapMethodDesc(methodDesc))
                            }
                        }
                    }
                }

                for(AbstractInsnNode node : methodNode.instructions.toArray()) {
                    if(node instanceof FieldInsnNode) {
                        if(this.getMixinClass(node.owner) != null) {
                            node.name = this.mapFieldName(node.owner, node.name, node.desc)
                        }
                    }
                    if(node instanceof MethodInsnNode) {
                        if(this.getMixinClass(node.owner) != null) {
                            node.name = this.mapMethodName(node.owner, node.name, node.desc)
                        }
                    }
                }
            }
        }
    }

    private String mapMethodName(String className, String methodName, String methodDesc) {
        String mixinClass = this.getMixinClass(className)

        boolean changed = false

        if(methodName.startsWith("invoke") || methodName.startsWith("call")) {
            String prefix = methodName.startsWith("invoke") ? "invoke" : "call"
            String strippedName = methodName.replace(prefix, "")
            strippedName = strippedName.charAt(0).toLowerCase().toString() + strippedName.substring(1)
            methodName = this.getParent().mapMethodName(mixinClass, strippedName, methodDesc)
            if(methodName != strippedName) {
                changed = true
            }
            methodName = prefix + methodName.charAt(0).toUpperCase().toString() + methodName.substring(1)
        } else if(methodName.startsWith("get") || methodName.startsWith("set") || methodName.startsWith("is")) {
            String prefix = methodName.startsWith("get") ? "get" : methodName.startsWith("set") ? "set" : "is"
            String strippedName = methodName.replace(prefix, "")
            strippedName = strippedName.charAt(0).toLowerCase().toString() + strippedName.substring(1)
            methodName = this.getParent().mapFieldName(mixinClass, strippedName, methodDesc)
            if(methodName != strippedName) {
                changed = true
            }
            methodName = prefix + methodName.charAt(0).toUpperCase().toString() + methodName.substring(1)
        }

        if(!changed) {
            methodName = this.getParent().mapMethodName(mixinClass, methodName, methodDesc)
        }
        return methodName
    }

    private String mapFieldName(String className, String fieldName, String fieldDesc) {
        String mixinClass = this.getMixinClass(className)
        return this.getParent().mapFieldName(mixinClass, fieldName, fieldDesc)
    }

    private String getMixinClass(String className) {
        return mixinClasses.get(className)
    }

}